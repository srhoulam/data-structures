'use strict';

function UnsortedStringList(maxItems) {
	var globalObject;

	try {
		globalObject = global;
	} catch(e) {
		globalObject = window;
	}

	if(this === globalObject) return; // perhaps throw an exception

	var length = maxItems || 100;

	this.array = new Array(length);

	this.numItems = 0;
	this.currentPos = 0;
}

UnsortedStringList.prototype.isFull = function() {
	return this.array.length === this.numItems;
};
UnsortedStringList.prototype.lengthIs = function() {
	return this.numItems;
};
UnsortedStringList.prototype.contains = function(item) {
	var found = false;

	for(var i=0; i < this.numItems && !found; i++)
		if(item == this.array[i])
			found = true;
	// we use `==` rather than `===` here for semantics.
	//	we are dealing with copies, not aliases, even
	//	though the interpreter stores duplicate immutables
	//	as aliases, not copies.
	// when we extend this to other kinds of objects, which
	//	may not be immutable, we will benefit from this
	//	decision.

	return found;
};
UnsortedStringList.prototype.insert = function(item) {
	this.array[this.numItems] = item.slice(0);
	this.numItems++;
};
UnsortedStringList.prototype.delete = function(item) {
	var location = 0;

	while(this.array[location] != item && location < this.numItems)
		location++;

	this.array[location] = this.array[this.numItems - 1];
	this.numItems--;
};
UnsortedStringList.prototype.reset = function() {
	this.currentPos = 0;
};
UnsortedStringList.prototype.getNext = function() {
	var next = this.array[this.currentPos++];

	this.currentPos %= this.numItems;

	return next.slice(0);
};

module.exports = UnsortedStringList;
